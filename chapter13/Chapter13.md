# 13. MSA

## 13.1 마이크로서비스 이해하기

단일 애플리케이션은 아래와 같은 문제가 있다.

- 전체를 파악하기 어렵다. : 코드가 점점 많아질수록 애플리케이션에 있는 각 컴포넌트의 역할을 파악하기 어려워진다.
- 테스트가 더 어렵다. : 애플리케이션이 커지면서 통합과 테스트가 더 복잡해진다.
- 라이브러리 간 충돌이 생기기 쉽다. : 애플리케이션의 한 기능에서 필요한 라이브러리 의존성이 다른 기능에 필요한 라이브러리와 호환되지 않을 수 있다.
- 확장에 비효율적이다. : 시스템 확장을 목적으로 더 많은 서버에 애플리케이션을 배포해야 할 때는 애플리케이션의 일부가 아닌 전체를 배포해야 한다.
- 적용할 테크놀로지를 결정할 때도 애플리케이션 전체를 고려해야한다. 애플리케이션에 사용할 프로그래밍 언어, 런타임 플랫폼, 프레임워크, 라이브러리를 선택할 때 애플리케이션 전체를 
고려해야한다.
- 프로덕션 배포에 많은 노력이 필요하다. : 애플리케이션을 한 덩어리로 배포하므로 개발 및 테스트를 더 철저히 해야한다.

이와 반대로 마이크로서비스 아키텍쳐는 아래와 같은 특성을 갖는다.
- 마이크로서비스는 쉽게 이해할 수 있다. : 다른 마이크로서비스와 협력할 떄 각 마이크로 서비스는 작으면서 한정된 처리를 수행한다. 따라서 마이크로 서비스는 자신의 목적에만
집중하므로 더 이해하기가 쉽다.
- 마이크로서비스틑 테스트하기 쉽다. : 크기가 작을수록 테스트가 더 쉬워진다.
- 라이브러리 호환성 문제가 생기지 않는다. : 각 마이크로서비스는 다른 마이크로서비스와 공유되지 않는 빌드 의존성을 가지므로 라이브러리 충돌 문제가 생기지 않는다.
- 독자적으로 규모를 조정할 수 있다. : 마이크로서비스는 다른 마이크로서비스에 독립적이다. 따라서 메모리 할당, 인스턴스 수를 비교적 자유롭게 조정할 수 있다.
- 각 마이크로서비스에 적용할 기술을 다르게 선택할 수 있다. : 각 마이크로서비스에 사용할 프로그래밍 언어, 플랫폼, 프레임워크, 라이브러리를 서로 다르게 선택할 수 있다.
- 마이크로서비는 배포에 자유롭다. : 마이크로서비스 아키텍쳐 기반으로 개발된 애플리케이션이 여러 개의 마이크로서비스로 구성됐더라도 각 마이크로서비스를 따로 배포할 수 있다.
또한, 각 마이크로서비스는 목적에 특화되어 있으므로 프로덕션으로 이양해는 데 따른 노력이 거의 들지 않는다.


마이크로서비스가 이러한 이점이 있지만 노력없이 되는 것은 아니다. 마이크로서비스 아키텍쳐는 분산 아키텍쳐이므로 네트워크 지연과 같은 문제들이 발생할 수 있다. 따라서 마이크로서비스
아키텍쳐를 고려할 때 반드시 염두해야하는 것이다. 마이크로서비스로의 원격호출이 많이 추가될수록 애플리케이션의 실행은 더 느려질 수 있다.
또한, 마이크로서비스 아키텍쳐로 개발하는 것에 대한 타당성도 고려해야한다. 


## 13.2 서비스 레지스트리 설정하기
스프링 클라우드는 큰 프로젝트이며, 마이크로서비스 개발을 하는 데 필요한 여러 개의 부속 프로젝트로 구성된다. 이중 하나가 넷플릭스이며, 이는 넷플릭스 오픈 소스로부터
다수의 컴포넌트를 제공한다. 이 컴포넌트 중에 넷플릭스 서비스 레지스트리인 유레카(Eureka)가 있다.

### 유레카란?
<strong>유레카</strong>는 마이크로서비스가 서로를 찾을 때 사용하는 서비스 레지스트리의 이름이다. 유레카는 마이크로서비스 애플리케이션에 있는 모든 서비스의 중앙 집중
레지스트리로 작동한다. 유레카 자체도 마이크로 서비스로 생각할 수 있으며, 더 큰 애플리케이션에서 서로 다른 서비스들이 서로를 찾는 데 도움을 주는 것이 목적이다.
이러한 역할 떄문에 서비스를 등록하는 유레카 서비스 레지스트리를 가장 먼저 설정하는 것이 좋다.

서비스 인스턴스가 시작될 떄 해당 서비스는 자신의 이름을 유레카에 등록한다. 어느 순간에 다른 서비스가 어떤 서비스를 사용해야할 때가 온다. 이때 '어떤' 서비스의 호스트명, 포트를
하드코딩하는 것이 아닌 유레카에서 알아내면 된다. 그러면 유레카는 찾고자하는 인스턴스의 정보를 알려준다.

다음으로 '그' 서비스는 '어떤' 서비스의 어떤 인스턴스를 사용할지를 결정해야한다. 이때 특정 인스턴스를 매번 선택하는 것을 피하기 위해서(부하 분산) 클라이언트 측에서
동작하는 로드 밸런싱 알고리즘을 적용하는 것이 조핟. 이 때 사용할 수 있는 것이 다른 넷플릭스 프로젝트인 리본이다.

### 클라이언트 측의 로드밸런서를 사용하는 이유
로드 밸런서는 주로 단일 중앙 집중화된 서비스가 서버 측에서 사용됐다. 그러나 이와 반대로 리본은 각 클라이언트에서 실행되는 클라이언트 측의 로드 밸런서이다.
클라이언트 측의 로드 밸러서인 리본은 중앙 집중화된 로드 밸러서에 비해 몇 가지 장점을 갖는다. 각 클라이언트에 하나의 로컬 로드 밸런서가 있으므로 클라이언트 수에 비례하여
로드 밸런서의 크기가 자연스럽에 조정된다. 또한, 서버에 연결된 모든 서비스에 획일적으로 같은 구성을 사용하는 대신, 로드 밸런서는 각 클라이언트에 가장 적합한 로드 밸런싱
알고리즘을 사용하도록 구성할 수 있다.

```xml
<properties>
    <java.version>11</java.version>
    <spring-cloud.version>2021.0.6</spring-cloud.version>
</properties>
<dependencies>
		<dependency>
			<groupId>org.springframework.cloud</groupId>
			<artifactId>spring-cloud-starter-netflix-eureka-server</artifactId>
		</dependency>

		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-test</artifactId>
			<scope>test</scope>
		</dependency>
</dependencies>
<dependencyManagement>
<dependencies>
    <dependency>
        <groupId>org.springframework.cloud</groupId>
        <artifactId>spring-cloud-dependencies</artifactId>
        <version>${spring-cloud.version}</version>
        <type>pom</type>
        <scope>import</scope>
    </dependency>
</dependencies>
</dependencyManagement>
```
dependencyManagement를 보면 spring-cloud.version 의존성이 정해져 있다. 이 의존성은 ```<properties>...</properties>```에 있다.

```java

@SpringBootApplication
@EnableEurekaServer
public class ServiceRegistryApplication {

	public static void main(String[] args) {
		SpringApplication.run(ServiceRegistryApplication.class, args);
	}

}
```
```@EnableEurekaServer```로 유레카 서버임을 선언한다. 실행 후 ```http://localhost:8080```로 접속하면 유레카 대시보드를 볼 수 있다.
현재는 아무 서비스도 등록하지 않았으므로 "Application"에 'No instances available' 메시지가 나타난다.


## 13.2.1 유레카 구성하기 
하나보다는 여러 개의 유레카 서버가 함께 동작하 것이 안전하므로 유레카 서버들이 클러스터로 구성되는 것이 좋다. 왜냐하면 여러 개의 유레카 서버가 있을 경우 그 중 
하나에 문제가 생기더라도 단일 장애점(Single Point of Failure)이 생기지 않을 것이기 때문이다. 따라서 기본적으로 유레카는 다른 유레카 서버로부터 서버 레지스트리를
가져오거나 다른 유레카 서버의 서비스로 자신을 등록하기도 한다.

프로덕션에서는 유레카의 고가용성이 바람직하다. 그러나 개발 시에 두 개 이상의 유레카서버를 실행하는 것은 불필요하다. 그러나 유레카 서버를 올바르게 구성하지 않으면 
30초 마다 에러 로그를 출력한다. 30초마다 다른 서버와 통신하며 생사여부를 알리고 레지스트리를 공유하기 때문이다.

```yaml
server:
  port: 8761
eureka:
  instance:
    hostname: localhost
  client:
    fetch-registry: false
    register-with-eureka: false
    service-url:
      defaultZone: http://${eureka.instance.hostname}:${server.port}/eureka/
  server:
    enable-self-preservation: false

```
여기서 포트는 8761, 호스트 네임은 localhost로 설정했다. 이는 유레카가 실행되는 호스트 이름과 포트를 나타낸다.
fetchRegistry와 registerWithEureka는 유레카와 상호작용 하는 방법을 알려주기 위해서 다른 마이크로서비스에 설정할 수 있는 속성들이다.
그러나 유레카 역시 마이크로서비스이므로, 두 속성은 해당 유레카 서버가 다른 유레카 서버와 상호작용하는 방법을 알려주기 위해서 사용할 수 있다.

두 속성의 기본값은 true 이다. 즉, 해당 유레카 서버가 다른 유레카로부터 레지스트리 정보를 가져오며, 다른 유레카 서비스의 서비스로 자신을 등록해야 한다는 것을 나타낸다.
마지막으로 serviceUrl을 설정했다. 이는 영역이름과 이 영역에 해당하는 하나 이상의 유레카 서버 URL을 포함하며, 이 값은 Map에 저장된다. 
Map의 키인 defaultZone은 클라이언트(여기서는 유레카 자신)가 자신이 원하는 영역을 지정하지 않았을 때 사용된다. 여기서는 유레카가 단독이므로
defaultZone에 해당하는 URL은 유레카 자신의 URL을 나타내며 중괄호 안 다른 매핑된 값으로 대체된다. 즉 ```http://localhost:8761```이 된다.

### 자체-보존 모드 비활성
```eureka.server.enableSelfPreservation``` 이 있다. 유레카 서버는 서비스 인스턴스(유레카 서버의 클라이언트)가 자신을 등록하고 등록 갱신 요청을 30초마다
전송하기를 기다린다. 일반적으로 세 번까지(90초 정도) 동안 서비스 인스턴스로부터 등록 갱신 요청을 유레카 서버가 받지 못하면, 해당 서비스 인스턴스 등록을 취소하게 된다.
그리고 만일 이렇게 중단되는 서비스의 수가 임계값(threshold)을 초과하면 유레카는 네트워크에 문제가 생긴 것으로 간주하고 레지스트리에 등록된 나머지 서비스 데이터를 보존
하기 위해서 자체-보존 모드로 돌입된다. 따라서 추가적인 서비스 인스턴스의 등록 취소가 방지된다.

프로덕션에서는 도움이 되지만 개발 초기는 오히려 문제가 될 수 있다. 따라서 false로 설정하는 것이 좋다. 갱신 요청을 받을 수 없거나 서비스 인스턴스들의 
상태가 자주 변경될 수 있는 개발 상황에서 자체-보존을 사용하면 다른 서비스 등록에 문제가 발생할 수 있다.


## 13.2.2 유레카 확장

### 프로덕션 환경의 스프링 클라우드 서비스
개발 단계에서는 유레카의 고가용성과 보안은 개발 시에는 중요하지 않지만 프로덕션 상황에서는 다르다. SpringConfig, Hystrix 등으로 이런 점을 커버해 볼 것이다.
두 개 이상의 유레카 인스턴스를 구성하는 가장 쉽고 간단한 방법은 application.yml에 스프링 프로파일을 지정하는 것이다. 그리고 그 다음에 한 번에 하나씩 프로파일을 
사용해서 유레카를 두번 시작하면 된다. 

## 13.3 서비스 등록하고 찾기
서비스가 등록되지 않으면 유레카 서비스 레지스트리는 쓸모가 없다. 우리 서비스를 다른 서비스에서 찾아서 사용하게 하려면, 유레카 서비스 레지스트리의 클라이언트로 활성화 
시켜면 된다. 즉, 애플리케이션을 서비스 레지스트리 클라이언트로 활성화 하기 위해서는 의존성을 추가해야한다. 

```xml
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>
</dependency>
```

해당 의존성을 지정하면 유레카를 이용해서 서비스를 찾는데 필요한 모든 것이 자동으로 추가된다. 예를 들어 유레카 클라이언트 라이브러리, 리본 로드 밸런서 등이다. 
따라서 우리 애플리케이션을 유레카 서비스 레지스트리의 클라이언트로 활성화 시킬 수 있다. 즉, 애플리케이션이 시작되면 8761포트로 서비스하는 유레카 
서버에 연결하고 UNKNOWN으로 유레카가 애플리케션 자신을 등록한다.


## 13.3.1 유레카 클라이언트 속성 구성하기
```yaml
server:
  port: 0
spring:
  application:
    name: test-service
```
이렇게하면 이 서비스를 사용하는 서비스에서는 test-service라는 이름으로 이 서비스를 찾을 수 있다. 이를 통해서 ```spring.application.name```이 꽤나 중요한
속성임을 알 수 있다. 이 속성이 유레카 서버에 등록되는 이름이기 떄문이다. 스프링 클라우드 태스크(Cloud Task)와 스프링 클라우드 슬루스(Spring Cloud Sleuth)
같은 다른 스프링 클라우드 프로젝트에서도 서비스를 식별하기 위해서 해당 속성을 이용한다.

모든 스프링 MVC와 스프링 WebFlux 애플리케이션은 기본적으로 8080을 리스닝한다. 그러나 서비스는 유레카를 통해서만 찾으므로 실질적으로 포트는 상관 없다. 서비스가 
리스닝하는 포트를 유레카가 알고 있기 때문이다. 따라서 localhost에서 실행될 때 생길 수 있는 서비스의 포트 충돌을 막기 위해서 각 서비스 애플리케이션의 포트를 0으로 
설정할 수 있다. 이처럼 포트를 0으로 설정하면 포트 번호가 무작위로 선택된다.

다음으로 유레카 서버의 위치를 생각해보자. 기본적으로 유레카 클라이언트는 유레카 서버가 localhost의 8761을 리스닝한다고 간주한다. 개발 시에는 용이하지만 프로덕션에서는
적합하지 않으므로 유레카 서버의 위치를 정해줘야한다.
```yaml
eureka:
  client:
    service-url:
      defaultZone: http://localhost:8761/eureka/
```
이러면 해당 유레카 서버에 등록이 된다. 이경우 유레카 서버가 제대로 작동 중이라면 문제가 없지만 유레카 서버가 중단되면 클라이언트 서비스가 등록되지 않을 것이다. 따라서 이를 방지하기
위해서 두 개 이상의 유레카 서버를 사용할 수도 있다. defaultZone에 ','으로 구분자를 주면 된다. 그러면 서비스가 실행되면서 첫 번째 유레카를 방문하고 문제가 있다면
두 번째 피어로 지정된 유레카 서버의 레지스트리에 등록을 시도하게 된다. 만일 첫 번째 유레카 서버가 온라인이 되면 해당 서비스의 등록 정보가 
포함된 피어 서버 레지스트리가 복제된다.

## 13.3.2 서비스 사용하기
서비스를 사용하는 컨슈머 코드에 해당 서비스 인스턴스의 URL을 하드코딩하는 것은 좋지 않다. 이 경우 사용되는 서비스의 특정 인스턴스와 해당 컨슈머가 밀접하게
결합됨을 물론이고, 사용되는 서비스의 호스트나 포트가 변경되면 해당 컨슈머의 실행 중당을 초래할 수 있다. 

유레카 서버에서 서비스를 찾을 때 컨슈머 애플리케이션이 할 일이 있다. 즉, 같은 서비스의 인스턴스가 여러 개일 때도 유레카 서버는 서비스 검색에 응답할 수 있다. 따라서 만일
컨슈머가 ingredient-service라는 서비스를 요청했는데 6개 정도가 반환된다면 어떻게 해야할까?

좋은 소식은, 이 경우 컨슈머 애플리케이션은 자신이 서비스 인스턴스를 선택하지 않아도 되며, 특정 서비스 인스턴스를 명시적으로 알 필요도 없다. 스프링 클라우드 유레카 클라이언트
지원에 포함된 리본 클라이언트 로드 밸런서를 사용해서 서비스 인스턴스를 쉽게 찾아서 선택하고 사용할 수 있기 때문이다. 유레카 서버에서 찾은 서비스를 선택 및 사용하는 방법은 아래의 두
가지가 있다.

- 로드 밸런싱된 RestTemplate
- Feign에서 생성된 클라이언트 인터페이스
