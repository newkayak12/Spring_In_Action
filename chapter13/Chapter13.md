# 13. MSA

## 13.1 마이크로서비스 이해하기

단일 애플리케이션은 아래와 같은 문제가 있다.

- 전체를 파악하기 어렵다. : 코드가 점점 많아질수록 애플리케이션에 있는 각 컴포넌트의 역할을 파악하기 어려워진다.
- 테스트가 더 어렵다. : 애플리케이션이 커지면서 통합과 테스트가 더 복잡해진다.
- 라이브러리 간 충돌이 생기기 쉽다. : 애플리케이션의 한 기능에서 필요한 라이브러리 의존성이 다른 기능에 필요한 라이브러리와 호환되지 않을 수 있다.
- 확장에 비효율적이다. : 시스템 확장을 목적으로 더 많은 서버에 애플리케이션을 배포해야 할 때는 애플리케이션의 일부가 아닌 전체를 배포해야 한다.
- 적용할 테크놀로지를 결정할 때도 애플리케이션 전체를 고려해야한다. 애플리케이션에 사용할 프로그래밍 언어, 런타임 플랫폼, 프레임워크, 라이브러리를 선택할 때 애플리케이션 전체를 
고려해야한다.
- 프로덕션 배포에 많은 노력이 필요하다. : 애플리케이션을 한 덩어리로 배포하므로 개발 및 테스트를 더 철저히 해야한다.

이와 반대로 마이크로서비스 아키텍쳐는 아래와 같은 특성을 갖는다.
- 마이크로서비스는 쉽게 이해할 수 있다. : 다른 마이크로서비스와 협력할 떄 각 마이크로 서비스는 작으면서 한정된 처리를 수행한다. 따라서 마이크로 서비스는 자신의 목적에만
집중하므로 더 이해하기가 쉽다.
- 마이크로서비스틑 테스트하기 쉽다. : 크기가 작을수록 테스트가 더 쉬워진다.
- 라이브러리 호환성 문제가 생기지 않는다. : 각 마이크로서비스는 다른 마이크로서비스와 공유되지 않는 빌드 의존성을 가지므로 라이브러리 충돌 문제가 생기지 않는다.
- 독자적으로 규모를 조정할 수 있다. : 마이크로서비스는 다른 마이크로서비스에 독립적이다. 따라서 메모리 할당, 인스턴스 수를 비교적 자유롭게 조정할 수 있다.
- 각 마이크로서비스에 적용할 기술을 다르게 선택할 수 있다. : 각 마이크로서비스에 사용할 프로그래밍 언어, 플랫폼, 프레임워크, 라이브러리를 서로 다르게 선택할 수 있다.
- 마이크로서비는 배포에 자유롭다. : 마이크로서비스 아키텍쳐 기반으로 개발된 애플리케이션이 여러 개의 마이크로서비스로 구성됐더라도 각 마이크로서비스를 따로 배포할 수 있다.
또한, 각 마이크로서비스는 목적에 특화되어 있으므로 프로덕션으로 이양해는 데 따른 노력이 거의 들지 않는다.


마이크로서비스가 이러한 이점이 있지만 노력없이 되는 것은 아니다. 마이크로서비스 아키텍쳐는 분산 아키텍쳐이므로 네트워크 지연과 같은 문제들이 발생할 수 있다. 따라서 마이크로서비스
아키텍쳐를 고려할 때 반드시 염두해야하는 것이다. 마이크로서비스로의 원격호출이 많이 추가될수록 애플리케이션의 실행은 더 느려질 수 있다.
또한, 마이크로서비스 아키텍쳐로 개발하는 것에 대한 타당성도 고려해야한다. 


## 13.2 서비스 레지스트리 설정하기
스프링 클라우드는 큰 프로젝트이며, 마이크로서비스 개발을 하는 데 필요한 여러 개의 부속 프로젝트로 구성된다. 이중 하나가 넷플릭스이며, 이는 넷플릭스 오픈 소스로부터
다수의 컴포넌트를 제공한다. 이 컴포넌트 중에 넷플릭스 서비스 레지스트리인 유레카(Eureka)가 있다.

### 유레카란?
<strong>유레카</strong>는 마이크로서비스가 서로를 찾을 때 사용하는 서비스 레지스트리의 이름이다. 유레카는 마이크로서비스 애플리케이션에 있는 모든 서비스의 중앙 집중
레지스트리로 작동한다. 유레카 자체도 마이크로 서비스로 생각할 수 있으며, 더 큰 애플리케이션에서 서로 다른 서비스들이 서로를 찾는 데 도움을 주는 것이 목적이다.
이러한 역할 떄문에 서비스를 등록하는 유레카 서비스 레지스트리를 가장 먼저 설정하는 것이 좋다.

서비스 인스턴스가 시작될 떄 해당 서비스는 자신의 이름을 유레카에 등록한다. 어느 순간에 다른 서비스가 어떤 서비스를 사용해야할 때가 온다. 이때 '어떤' 서비스의 호스트명, 포트를
하드코딩하는 것이 아닌 유레카에서 알아내면 된다. 그러면 유레카는 찾고자하는 인스턴스의 정보를 알려준다.

다음으로 '그' 서비스는 '어떤' 서비스의 어떤 인스턴스를 사용할지를 결정해야한다. 이때 특정 인스턴스를 매번 선택하는 것을 피하기 위해서(부하 분산) 클라이언트 측에서
동작하는 로드 밸런싱 알고리즘을 적용하는 것이 조핟. 이 때 사용할 수 있는 것이 다른 넷플릭스 프로젝트인 리본이다.

### 클라이언트 측의 로드밸런서를 사용하는 이유
로드 밸런서는 주로 단일 중앙 집중화된 서비스가 서버 측에서 사용됐다. 그러나 이와 반대로 리본은 각 클라이언트에서 실행되는 클라이언트 측의 로드 밸런서이다.
클라이언트 측의 로드 밸러서인 리본은 중앙 집중화된 로드 밸러서에 비해 몇 가지 장점을 갖는다. 각 클라이언트에 하나의 로컬 로드 밸런서가 있으므로 클라이언트 수에 비례하여
로드 밸런서의 크기가 자연스럽에 조정된다. 또한, 서버에 연결된 모든 서비스에 획일적으로 같은 구성을 사용하는 대신, 로드 밸런서는 각 클라이언트에 가장 적합한 로드 밸런싱
알고리즘을 사용하도록 구성할 수 있다.

```xml
<properties>
    <java.version>11</java.version>
    <spring-cloud.version>2021.0.6</spring-cloud.version>
</properties>
<dependencies>
		<dependency>
			<groupId>org.springframework.cloud</groupId>
			<artifactId>spring-cloud-starter-netflix-eureka-server</artifactId>
		</dependency>

		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-test</artifactId>
			<scope>test</scope>
		</dependency>
</dependencies>
<dependencyManagement>
<dependencies>
    <dependency>
        <groupId>org.springframework.cloud</groupId>
        <artifactId>spring-cloud-dependencies</artifactId>
        <version>${spring-cloud.version}</version>
        <type>pom</type>
        <scope>import</scope>
    </dependency>
</dependencies>
</dependencyManagement>
```
dependencyManagement를 보면 spring-cloud.version 의존성이 정해져 있다. 이 의존성은 ```<properties>...</properties>```에 있다.

```java

@SpringBootApplication
@EnableEurekaServer
public class ServiceRegistryApplication {

	public static void main(String[] args) {
		SpringApplication.run(ServiceRegistryApplication.class, args);
	}

}
```
```@EnableEurekaServer```로 유레카 서버임을 선언한다. 실행 후 ```http://localhost:8080```로 접속하면 유레카 대시보드를 볼 수 있다.
현재는 아무 서비스도 등록하지 않았으므로 "Application"에 'No instances available' 메시지가 나타난다.


## 13.2.1 유레카 구성하기 
하나보다는 여러 개의 유레카 서버가 함께 동작하 것이 안전하므로 유레카 서버들이 클러스터로 구성되는 것이 좋다.

