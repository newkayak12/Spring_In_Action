# 14. 클라우드 구성 관리

## 14.1 구성 공유하기
몇 가지 속성 근원에 있는 속성들을 설정하여 스프링 애플리케이션을 구성할 수 있음을 우리는 여러 차례 지켜봐왔다. 만일 구성 속성을 런타임 환경을 변경하거나 런타임 환경에 
고유한 것이어야 한다면, 자바 시스템 속성 혹은 OS 환경 변수를 구성 속성으로 사용하는 것이 좋다. 그러나 값이 변경될 가능성이 거의 없고 애플리케이션에 특정되는 속성의
경우는 애플리케이션 패키지에 포함되어 배포되는 application.yml에 구성 속성을 지정하는 것이 좋은 선택이다.

간단한 애플리케이션에서는 큰 문제가 없다. 그러나 자바 시스템 속성이나 운영체제의 환경 변수에 구성 속성을 설정하는 경우는 해당 속성의 변경으로 인해 애플리케이션이
다시 시작되어야 한다는 것을 감안해야 한다. JAR/ WAR 파일 내부에 구성 속성을 포함시키는 경우는 해당 속성을 변경하거나 원래 값으로 돌려 놓으려면 빌드, 배포를 반복해야한다.

물론 예외가 있겠지만 대다수의 애플리케이션은 이런 과정을 수행함에 따라 리스크가 뒤따른다. 또한 실행 중인 애플리케이션에 이런 작업을 하는 것은 꽤나 문제가 있다.
또한, DB 비밀번호와 같은 일부 속성들은 보안에 민감한 값을 갖는다. 이런 속성 값은 각 애플리케이션의 속성에 지정될 때 암호화될 수 있지만, 사용 전에 해당 속성 값을 복호화
하는 애플리케이션을 수반해야한다. 

이런 이유로 중앙 집중식으로 구성을 관리할 떄는 어떤 이점이 있을지 알아보자.

- 구성이 더 이상 애플리케이션 코드에 패키징되지 않는다. 따라서 애플리케이션을 빌드, 배포하는 과정 없이 실행 중에 구성을 변경할 수 있다.
- 공통적인 구성을 공유하는 마이크로서비스가 자신의 속성 설정으로 유지/관리하지 않고도 동일한 속성을 공유할 수 있다. 그리고 속성 변경이 필요하면 한 곳에서
한 번만 수정하면 모든 곳에 적용된다.
- 보안에 민감한 구성은 애플리케이션 코드와는 별도로 암호화하고 유지/관리 할 수 있다. 그리고 복호화된 속성 값을 언제든지 애플리케이션에서 사용할 수 있으므로 복호화
를 하는 코드가 불필요해진다.

스프링 클라우드 구성 서버는 애플리케이션의 모든 마이크로서비스가 구성에 의존할 수 있는 서버를 사용해서 중앙 집중식 구성을 제공한다. 따라서 모든 서비스에 공통된 구성은
물론이고, 특정 서비스에 국한된 구성도 한 곳에서 관리할 수 있다.

스프링 클라우드 구성 서버는 애플리케이션의 모든 마이크로서비스가 구성에 의존할 수 있는 서버를 사용해서 중앙 집중식 구성을 제공한다. 따라서 모든 서비스에 공통된 구성은
물론이고, 특정 서비스에 국한된 구성도 한 곳에서 관리할 수 있다.


## 14.2 구성 서버 실행하기
스프링 클라우드 구성 서버는 집중화된 구성 데이터 소스를 제공한다. 구성 서버는 유레카처럼 더 큰 애플리케이션의 마이크로서비스로 생각할 수 있으며, 같은 애플리케이션에
있는 다른 서비스들의 구성 데이터를 제공하는 역할을 수행한다.
구성서버는 클라이언트가 되는 다른 서비스들이 구성 속성을 사용할 수 있도록 REST API를 제공한다. 구성 서버를 통해 제공되는 구성 데이터는 구성 서버 외부에 저장된다.

## 14.2.1 구성 서버 활성화 하기
더 큰 애플리케이션 시스템 내부의 또 다른 마이크로서비스인 구성 서버는 별개의 애플리케이션으로 개발되어 배포된다. 따라서 새로운 구성 서버 프로젝트를 생성해야 한다.

```xml
<dependencyManagement>
    <dependencies>
        <dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-dependencies</artifactId>
            <version>${spring-cloud.version}</version>
            <type>pom</type>
            <scope>import</scope>
        </dependency>
    </dependencies>
</dependencyManagement>
<dependencies>
    <dependency>
        <groupId>org.springframework.cloud</groupId>
        <artifactId>spring-cloud-config-server</artifactId>
    </dependency>
</dependencies>
```
이 의존성의 버전은 스프링 클라우드 릴리즈 트레인에 의해 결정된다. 
이후 구성 서버를 활성화시키면 된다. 구성 서버의 main에 ```@EnableConfigServer```를 추가하면 구성 서버를 활성화하여 자동-구성한다.
```java
@SpringBootApplication
@EnableConfigServer
public class ConfigServerApplication {
    public static void main(String[] args) {
        SpringApplication.run(ApplicationName.class, args);
    }
}
```
애플리케이션을 실행하고 구성 서버가 작동하는 것을 알아보기전, 한 가지 더 할 일이 있다. 구성 서버가 처리할 구성 속성들이 있는 곳을 알려줘야한다.
깃 혹은 네이티 위치를 사용할 수 있다. 일단 깃으로 살펴보면
```yaml
server:
  port: 8888
spring:
  cloud:
    config:
      server:
        git:
          uri: github url
```

혹은 리모트가 아닌 서버 파일로 진행하려면

```yaml
server:
  port: 8888
spring:
  cloud:
    config:
      server:
        native:
          search-locations: path
```
로 진행하면 된다.

이후 만약 구성 서버에 구성을 등록했다면, `curl localhost:8888/application/default` 로 접근하면 해당 구성 속성을 불러올 것이다.
여기서 구성 서버의 /application/default 경로에 대한 HTTP GET을 수행한다.

                구성 서버의 호스트, 포트                 스프링 프로필   
            `http://localhost:8888 / application / default  [/master]`
                                    애플리케이션 이름

첫 경로의 application은 구성 서버에 요청하는 애플리케이션의 이름이다. 
두 번째 부분은 애플리케이션에 활성화된 스프링 프로필 이름이다. 
요청 경로의 세 번째는 생략 가능하며, 구성 속성을 가져올 백엔드 GIT의 라벨이나 branch를 지정한다.

필요하다면 하위 경로에 구성 속성을 저장할 수도 있다. 이 때는 uri아래에 ```search-paths```를 지정하면 된다. 이는 쉼표로 복수로 지정할 수 있다.
또한, 와일드 카드(*)를 지정할 수도 있다.

### Git 레포지토리의 분기나 라벨에 구성 속성 저장하고 제공하기 -생략
### Git 백엔드를 사용한 인증


## 14.3 공유되는 구성 데이터 사용하기
중앙 집중식 구성 서버를 제공하는 것에 추가하여, 스프링 클라우드 구성 서버는 클라이언트 라이브러리도 제공한다. 

```xml
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-config</artifactId>
</dependency>
```
이처럼 의존성을 추가한 후 애플리케이션을 실행하면 자동-구성이 실행되어 구성 서버로부터 속성들을 가져오는 속성 소드(property source)를 등록한다. 기본적으로 
자동-구성은 구성 서버가 localhost의 8888포트에서 실행 중인 것으로 간주한다. 그러나 ```spring.cloud.config.uri``` 속성을 설정하면 구성 서버의
위치를 알려줄 수 있다.

```yaml
spring:
  cloud:
    config:
      uri: http://config.tacocloud.com:8888
```

이 속성은 구성 서버의 클라이언트가 되는 애플리케이션 자체에 설정되어야 한다. 
그러나 중앙 집중식 구성 서버가 있을 때는 대부분의 모든 구성이 이 서버에서 제공된다. 따라서 각 마크로서비스가 자신의 구성을 가질 필요가 없으며, 구성 서버의 위치를
지정하는 spring.cloud.config.ui와 구성 서버 애플리케이션을 알려주는 spring.application.name 속성만 각 마이크로서비스에 설정하면 된다.

>
>  ### 구성서버와 서비스 레지스트리 중 어느 것을 먼저 찾아야 하나?
> 
> 대개는 구성 서버로부터 유레카 서비스 레지스트리를 알아내도록 마이크로서비스를 설정할 것이다. 
> 이것은 애플리케이션의 모든 마이크로서비스에서 서비스 레지스트리의 명세를 갖지 않게 하는 통상적인 방법이다.
> 
> 또 다른 방법으로 구성 서버를 유레카에 등록한 후, 각 마이크로서비스가 구성 서버를 찾게 할 수도 있다. 만일 이 방법을 선호한다면 구성 서버를
> 유레카 클라이언트로 구성하고 spring.cloud.config.discovery.enabled를 true로 놓는다.
> 
> 이 방법의 단점은 각 마이크로 서비스가 시작될 때 두 번의 호출을 해야한다는 것이다. 즉, 구성 서버를 발견하기 위해서 유레카를 호출하고, 그다음에 구성 데이터를 가져오기 위해
> 구성 서버에 호출해야한다. 
> 

애플리케이션이 시작되면 구성 서버 클라이언트가 제공하는 속성 소스가 서버에 속성 값을 요청한 후 받으면 애플리케이션의 환경에서 이 속성들을 사용할 수 있다.
게다가 이 속성들은 효과적으로 캐싱되므로 구성 서버의 실행이 중단되더라도 사용할 수 있다. 

지금까지 구성 서버가 제공하는 구성 데이터가 간단하면서 모든 애플리케이션이나 프로파일을 대상으로 하였다. 그러나 때로는 특정 애플리케이션에 고유한 구성을 하거나,
특정 활성 프로필(active profile)을 갖는 애플리케이션이 실행 중일 때만 사용할 수 있는 구성을 해야 한다.

## 14.4 애플리케이션나 프로필에 특정된 속성 제공하기
구성 서버 클라이언트가 시작될 때는 애플리케이션의 이름과 활성 프로파일 모두를 포함하는 요청 경로를 사용해서 구성 서버 속성을 요청한다. 그리고 구성 서버가 구성 속성을 제공할
때는 클라이언트가 요청한 값을 고려해서 애플리케이션과 프로파일에 특정된 구성 속성을 해당 클라이언트에 반환한다.

애플리케이션 이름은 spring.application.name 속성을 설정하여 지정한다. 그리고 활성 프로필은 spring.profiles.actives 속성을 설정해서 지정할 수 있다.
애플리케이션과 프로필에 특정된 구성 속성을 사용할 떄 클아이언트 관점에서는 동일한 속성을 사용하므로 구성 서버를 사용했을 때와 다르지 않다.

## 14.4.1 애플리케이션에 특정된 속성 제공하기
한 애플리케이션의 모든 마이크로서비스들이 공통 구성 속성을 공유할 수 있다는 것이 구성 서버의 장점 중 하나이다. 그러나 하나의 마이크로서비스에만 공유하면서
모든 마이크로서비스가 공유할 필요 없는 속성들이 있을 때가 있다.

공유하는 구성과 더불어 구성 서버는 특정 애플리케이션을 대상으로하는 구성 속성을 관리할 수 있다. 이 경우 해당 애플리케이션의 spring.application.name 속성
값과 동일하게 구성 파일의 이름을 지정하는 것이 좋다.

ex)
- application.yml -> 공통 구성 속성
- application-production.yml -> production 프로필이 활성화된 경우의 공통 구성 속성
- [~]-service.yml -> 특정 구성 속성

애플리케이션 이름과 상관없이 application.yml 파일의 구성 속성을 받는다. 그러나 각 서비스 특화 애플리케이션 속성은 구성 속성이 구성 서버에 요청할 때 전송된다. 
그리고 존재하면 반환된다. application.yml, 특정 구성 속성이 중복되면 특정 속성들이 우선권을 갖는다. 

## 14.4.2 프로파일로부터 속성 제공하기
스프링 클라우드 구성 서버는 각 스프링 부트 애플리케이션에 사용했던 것과 똑같은 방법으로 프로파일에 특정된 속성들을 지원한다.

- 프로파일에 특정된 .properties 파일이나 YAML 파일들을 제공한다. 예를 들면, application-production.yml이란 이름의 구성 파일이 해당된다. 
- 하나의 YAML 파일 내부에 여러 개의 구성 그룹을 포함한다. 이 경우 3개의 하이픈(--)을 추가하고 그다음에 해당 프로파일의 이름을 나타내느 spring.profiles 속성을 지정한다.

## 14.6 실시간으로 구성 속성 리프레시하기
일반적으로 구성 변경을 포함해서 애플리케이션을 유지/보수할 때는 애플리케이션을 다시 배포하거나 최소한 다시 시작해야 한다. 그러나 이는 클라우드 기반의 애플리케이션에서는
문제가 될 수 있다. 따라서 중단 없이 실시간으로 속성을 변경하면 좋을 것이다.
물론 구성 서버는 애플리케이션 중단 없이 구성 속성을 리프레시할 수 있다.

- 수동식: 구성 서버 클라이언트는 '/actuator/refresh'의 특별한 액추에이터 엔드포인트를 활성화 한다. 그리고 각 서비스에서 이 엔드포인트로 HTTP POST 요청을 하면 구성
클라이언트가 가장 최근의 구성을 가져온다.
- 자동식: 레포지토리의 커밋 훅으로 리프레시를 트리거할 수 있다. 이 떄는 구성 서버와 이 클라이언트 간 통신을 위해서 스프링 클라우드 버스(Spring Cloud Bus)를 사용한다.

각 방식은 장단점이 있다. 수동 리프레시는 구성이 업데이트되는 시점을 더 정확하게 제어할 수 있다. 그러나 마이크로서비스의 인스턴스에 대해
개별적인 HTTP 요청이 수행되어야 한다. 반면에 자동식 리프레시는 애플리케이션의 모든 마이크로서비스에 대해 즉시 변경 구성을 적용한다.

